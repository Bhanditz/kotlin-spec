= Kotlin Language Specification
:numbered:

== Purpose and Format of this Specification

=== General
Kotlin is a general-purpose statically and strongly typed programming language. Kotlin supports imperative, object-oriented and
functional programming styles.
Its object-oriented system is based on single class inheritance and multiple interface inheritance.
Only classes can contain data and initialization code, and interfaces can contain abstract functional members
and, optionally, default implementations for them.

The Kotlin type system is based on nominal (rather than structural) subtyping with subtyping polymorphism (virtual
functional members), with support of generics -- a form of parametric polymorphism featuring constrained type
parameters, generic variance and type projections (a simple restricted form of existential types similar to Java
wildcards).

A static typing means that every expression has a known compile-time type and language guarantees that at
runtime it will evaluate to an instance of that type (except certain cases indicated by compiler warnings).

A strong typing means any conversions between different type that reuqire any processing, change value representation or
may fail at runtime require explicit invocation of conversion functions, they never can be hidden in simple assignments.
Implicit conversions are reserved for safe upcasts existing due to subtyping and variance. No user-defined implicit
conversions are supported either.

TODO: dynamic types, non-nullable types.

Kotlin syntax is intended to be concise, but without hurting readability. It supports traditional nested block
structure based on curly braces, but also features implicit semicolon inference, relieving a user of typing trailing
semicolons in most cases. Whitespace (except new lines) is generally insignificant outside string and character
literals, but in some cases it is required to separate certain tokens.

TODO: Describe main purposes, features and supported paradigms of Kotlin, general design principles.

=== Normative and Informative Text
TODO

=== Notations
All numbers in this specification are given in decimal notation unless explicitly specified otherwise. All characters
that can be interpreted both as characters from ASCII range and as similarly looking 
characters from a different part of Unicode character set shall be interpreted as ASCII characters. Logical 
connectives such as “or”, “and”, “not”, “if … then …” have their usual meaning as in the two-valued classical 
logic. In particular, "or" is not exclusive, and “if A, then B” is exactly equivalent to “B or not A”. If an exclusive "or"
is intended, it is usually written in a verbose form "exactly one of the following is true: ...". A phrase "A is true"
is an exact equivalent of just "A", and "A is false" is an exact equivalent of "not A". 
TODO: metavariables, font used for Kotlin code fragments.

=== Referenced Specifications

==== General
TODO

==== Unicode
TODO: Specify what version of the Unicode Standard is supported, and what is the upgrade and 
compatibility policy is in effect as newer versions of the Standard are released.

==== IEEE 754
TODO

==== Java Virtual Machine
TODO

==== ECMAScript
TODO

=== Compatibility Policy
TODO: Specify what the policy for the language evolution with respect to backwards compatibility is, 
and what the policy for compiler bug fixes is.

=== Errata Policy
This specification is intended to be free of contradictions and ambiguous language. But experience 
shows that for documents of such complexity it is not uncommon that some defects go unnoticed for 
some time. This sections outlines general principles that should be used by implementers of a compiler 
or other language tool in case a contradiction or ambiguous language is discovered.
TODO

=== Glossary
This section gives definitions of some terms used in this specification.

 *	angle brackets – Unicode characters LESS-THAN SIGN (U+003C) '<' and GREATER-THAN SIGN 
(U+003E) '>' in those contexts where they used as delimiters rather than operators.
 *	curly braces – Unicode characters LEFT CURLY BRACKET (U+007B) '{' and RIGHT CURLY BRACKET' 
(U+007D) '}'.
 *	textual order – top-to-bottom, left-to-right within a line (actually, order of chars in the source 
file, unrelated to RTL languages)
 * ASCII - TODO
 * dot - '.' FULL STOP
 * underscore - Unicode character '_' [black]+LOW LINE (U+005F)+.
TODO

== Language Overview

TODO: Non-normative language overview, with references to detailed normative specifications of all 
features.

== Compilation Process

=== General
TODO

=== Compiler Input and Output
TODO: Describe what files and streams can be input and output of the compiler.

=== Command Line
TODO: Describe encoding, parsing rules, syntax of the command line, and meaning of supported 
options.

=== Referenced Libraries

==== General
TODO: Describe how libraries can be referenced from a compilation, how possible conflicts are handled, 
how ill-formed libraries are handled, and what is an effect (if any) of an order in which libraries are 
referenced.

==== Standard Library
TODO: Describe what the standard library is, whether it has to be explicitly referenced, and what 
happens if it is ill-formed or does not contain some symbols that are assumed to exist in this 
specification.

=== Source Files
==== General
TODO

==== Supported Encodings
TODO
An implementation may choose to represent all source files in UTF-16 and support only non-surrogate Unicode characters up to U+FFFF.
Thus, letters that require a surrogate pair to be represented in UTF-16 would not be allowed on such implementations. For maximum
portatbility, it is recommended that Kotlin programs do not use Unicode characters above U+FFFF.

==== Ordering of Source Files
TODO: Describe what is an effect (if any) of an order in which source files are provided to the compiler.

===	Parsing
TODO: Give an overview of a parsing process, with a reference to detailed specification in §?.

=== Target Platforms
TODO

==== Java Virtual Machine
Platform Limitations

TODO: No dynamic type

==== ECMAScript
Platform Limitations

TODO: Different behavior of numeric types

=== Errors, Warnings and Messages
TODO

==== Use of Standard Output and Standard Error Streams
TODO

==== Early Compilation Termination
Affected Files 

TODO

=== Implementation Limitations
TODO

== Grammars and Parsing

=== General
A production from lexical grammar contains double colon after its name, a production from syntax grammar
contains a single colon after its name. Each alternative is given on a separate line. If all alternatives
are short (refer to only one production or terminal), they can be given on a single line after the words
"one of". Subscript opt denotes that an element is optional. Terminals are given in bold monospace font.

TODO: Grammar notations used in this specification, and general parsing rules (longest match rule, etc.), 
trailing U+001A ?

=== Lexical Grammar
_input::_::
 	_shebang~opt ~input-elements~opt~_ (TODO: implement standalone shebang)

_shebang::_::
	+*#!*+ _input-characters~opt~_

_input-characters::_::
	_input-characters~opt~ input-character_

_input-character::_::
	Any Unicode character point except _new-line-character_

_new-line-character::_::
	_line-feed_ +
	_carriage-return_ +
	(TODO: Some languages also support U+0085, U+2028, U+2029)

_new-line::_::
	_line-feed_ +
	_carriage-return line-feed~opt~_ +
	(TODO: Some languages also support U+0085, U+2028, U+2029)

_line-feed::_::
	[black]+LINE FEED (U+000A)+

_carriage-return::_::
	[black]+CARRIAGE RETURN (U+000D)+

_input-element::_::
	_whitespace_ +
	_comment_ +
	_token_

_whitespace::_::
	_new-line_ +
	[black]+SPACE (U+0020)+ +
	[black]+CHARACTER TABULATION (U+0009)+ +
	[black]+FORM FEED (U+000C)+ +
	(TODO: Do we support other Unicode whitespace?)

_comment::_::
	_end-of-line-comment_ +
	_delimited-comment_

_end-of-line-comment::_::
	+*//*+ _input-characters~opt~_

_delimited-comment::_::
	+*/&#x002a;*+ _delimited-comment-parts~opt~ asterisks_ +*/*+

_delimited-comment-parts::_::
	_delimited-comment-parts~opt~ delimited-comment-part_

_delimited-comment-part::_::
	_delimited-comment_ +
	_not-asterisk_ +
	_asterisks not-slash-or-asterisk_

_asterisks::_::
	_asterisks~opt~_ +*&#x002a;*+

_not-asterisk::_::
	Any Unicode character +*&#x002a;*+

_not-slash-or-asterisk::_::
	Any Unicode character except +*&#x002a;*+ and +*/*+

_token::_::
	_identifier_ +
	_field-identifier_ +
	_keyword_ +
	_integer-literal_ +
	_real-literal_ +
	_char-literal_ +
	_string-literal_ +
	_operator_

_identifier::_::
	_regular-identifier_ +
	_escaped-identifier_

_field-identifier::_::
	+*$*+ <nospace> _identifier_ (TODO: consider moving to syntax grammar)

_regular-identifier::_::
	_keyword-or-identifier_ other than a _keyword_

_keyword-or-identifier::_::
	_identifier-start identifier-parts~opt~_

_identifier-start::_::
	_letter_

_letter::_::
	Any Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl

_identifier-parts::_::
	_identifier-parts~opt~ identifier-part_

_identifier-part::_::
	_identifier-start_
	_digit_

_digit::_::
	Any Unicode character of class Nd

_escaped-identifier::_::
	_backtick escape-identifier-characters backtick_ (TODO: Unicode escapes)

_backtick::_::
	[black]+GRAVE ACCENT (U+0060)+

_escape-identifier-characters::_::
	_escape-identifier-characters~opt~ escape-identifier-character_

_escape-identifier-character_:: 
	Any input-character except _backtick_

_keyword::_::
	one of +*as break class continue do else false for fun if in interface is null*+ +
	+*object package return super this This throw true try typealias val var when while*+ +
	any _keyword-or-identifier_ consisting of one or more characters _

_decimal-digit::_::
	one of +*0 1 2 3 4 5 6 7 8 9*+

_integer-literal::_::
	_decimal-digits integer-literal-suffix~opt~_

_integer-literal-suffix::_::
	+*L*+

_decimal-digits::_::
	_decimal-digits~opt~ decimal-digit_

_float-literal::_::
	TODO

_hex-digit::_::
	one of +*0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F*+

_hex-digits::_::
	_hex-digits~opt~ hex-digit_

_hex-literal::_::
	+*0x*+ _hex-digits_ +
	+*0X*+ _hex-digits_

_char-literal::_::
	TODO

==== Identifiers
An identifier can start with a letter or underscore, followed by zero or more letters, underscores or 
decimal digits. Any token of this form is an identifier, unless it is explicitly reserved as a keyword.
Identifiers are case-sensitive: kotlin, Kotlin and KOTLIN are 3 different identifiers. A single underscore
and sequences of 2, 3, etc. underscores are reserved keywords, but otherwise underscore is valid everywhere
in an identifier.
_[Note:_ A digit is defined as a member of Unicode class Nd, that class contains many characters beyond
ten regular ASCII digits. _End Note]_
_[Note:_ Unicode escape sequences are not supported in regular identifiers. _End Note]_

==== Keywords
If a use of an identifier with a spelling matching a keyword is desired, an escaped identifier may be used.

==== Decimal Literals
An decimal literal is a sequence of one or more ASCII decimal digits, followed by an optional L (LATIN CAPITAL
LETTER L, U+004C). A literal without a suffix represents a constant value of type Int (TODO: it is more complicated).
A literal with suffix L represents a constant value of type Long. An decimal literal represents a constant value
that results from reading it in decimal notation. The value of a literal must lie within the range of its type.
[Note: Decimal literals always represent positive integers. For example, an expression -5 is the unary 
operator minus applied to an operand that is a decimal literal 5, rather than a single decimal literal. End 
Note]

It is an error if a decimal literal other than 0 starts with digit 0. [Example: Literals 00, 007 are errors. 
End Example]. It is an error if a decimal literal has an adjacent identifier or keyword before of after it
without any characters separating these tokens. [Example: 0less1 is an error. End Example]

==== Hexadecimal Literals
An hexadecimal literal consists of a prefix 0x or 0X, followed a sequence of one or more hexadecimal 
digits, followed by an optional  L (LATIN CAPITAL LETTER L, U+004C). A literal without a suffix represents
a constant value of type Int. A literal with suffix L represents a constant value of type Long. 
A hexadecimal digit is an ASCII decimal digit or an upper-case or lower-case letter in the range A-F 
(upper-case and lower-case letters are equivalent, having numeric values 10-15, respectively). Prefixes 
0x and 0X are equivalent.
An hexadecimal literal represents a constant value that results from reading it in hexadecimal notation 
(with leading zeros allowed). The value of a literal must lie within the range of its type.

TODO: overflow behavior

=== Syntax Grammar
_expression-or-block:_::
	_expression_ +
	_assignment_ +
	_block_

_expression:_::
	_disjunction_

_assignment:_::
	_assignable-expression assignment-operator disjunction_

_assignment-operator:_::
	= +
	+= +
	-= +
	*= +
	/= +
	%=

_disjunction:_::
	_conjunction_ +
	_disjunction_ +*||*+ _conjunction_

_conjunction:_::
	_equality_ +
	_conjunction_ +*&&*+ _equality_

_equality:_::
	_comparison_ +
	_equality equality-operator comparison_

_equality-operator:_::
	== +
	!= +
	=== +
	!==

_comparison:_::
	_infix-operation_ +
	_comparison comparison-operator infix-operation_

_comparison-operator:_::
	> +
	< +
	>= +
	<=

_infix-operation:_::
	_elvis-expression_ +
	_elvis-expression is-operator type_ +
	_infix-operation in-operator elvis-expression_

_is-operator:_::
	is +
	! <nospace> is

_in-operator:_::
	in +
	! <nospace> in

_elvis-expression:_::
	_infix-function-call_ +
	_elvis-expression_ ?: _infix-function-call_

_infix-function-call:_::
	_range-expression_ +
	_infix-function-call simple-name range-expression_

_range-expression:_::
	_additive-expression_ +
	_range-expression_ .. _additive-expression_

_additive-expression:_::
	_multiplicative-expression_ +
	_additive-expression additive-operator multiplicative-expression_

_additive-operator:_::
	+ +
	-

_multiplicative-expression:_::
	_as-expression_ +
	_multiplicative-expression multiplicative-operator as-expression_

_multiplicative-operator:_::
	* +
	/ +
	%

_as-expression:_::
	_prefix-unary-expression_ +
	_as-expression as-operator type_

_as-operator:_::
	as +
	as <nospace> ?

_prefix-unary-expression:_::
	_postfix-unary-expression_ +
	_prefix-unary-operator prefix-unary-expression_ +
	_annotation prefix-unary-expression_ +
	_label prefix-unary-expression_

_prefix-unary-operator:_::
	+ +
	- +
	++ +
	-- +
	!

_annotation:_::
	TODO

_label:_::
	TODO

_postfix-unary-expression:_
	_assignable-expression_ +
	_invocation-expression_ +
	_postfix-unary-expression postfix-unary-operator_

_postfix-unary-operator:_::
	++ +
	-- +
	!!

_assignable-expression:_::
	_primary-expression_ +
	_indexing-expression_ +
	_member-access_

_primary-expression:_::
	_parenthesized-expression_ +
	_literal_ +
	_function-literal_ +
	_this-expression_ +
	_super-expression_ +
	_object-literal_ +
	_simple-name_ +
	_field-name_ +
	_callable-reference_ +
	_package-expression_ +
	_jump-expression_ +
	_conditional-expression_ +
	_loop-expression_ +
	_try-expression_

_callable-reference:_::
	:: _simple-name_ +
	TODO (qualified reference)

_parenthesized-expression:_::
	( _expression_ )

_literal:_::
	_boolean-literal_ +
	_integer-literal_ +
	_float-literal_ +
	_character-literal_ +
	_string-literal_ +
	_null-literal_ 

_boolean-literal:_::
	true +
	false

_null-literal:_::
	null

_this-expression:_::
	this _label-reference~opt~_

_super-expression:_::
	super _supertype-reference~opt~_ label-referenceopt

_supertype-reference:_::
	< _type_ >

_label-reference:_::
	@ <nospace> _identifier_

_invocation-expression:_ ::
	_postfix-unary-expression type-arguments~opt~ argument-list~opt~ trailing-lambda_ +
	_postfix-unary-expression type-arguments~opt~ argument-list_ +
	_postfix-unary-expression type-arguments_
 


TODO: Specify rules that guarantee correct grouping in parsing of types () –> Int? and () -> 
Unit.() -> Unit.
TODO: Specify places where parsing as blocks is preferred to parsing as function literals (if, else, when, 
loops).
Block is parsed as a function literal if it has at least one leading label or annotation (only if there is a 
potential ambiguity – there are places where it can only be parsed as a block, e.g. after try keywords, 
and no labels or annotations are allowed there).
Parsing of else branches in nested if statements (possibly within a when statement)
When newline commits a statement, and when statement is parsed greedily.
Possible empty statements: if(true) else;
[Example: Parsing functional types before -> token in lambdas and with statements. End Example]
Note: Parenthesization or leading -> forces parsing of a block as a function literal. End Note]

==== Grammar Ambiguities
TODO: Specify what are possible grammar ambiguities (if any), and how they should be handled.


== Symbols

=== General
Programs can declare and reference different kinds of entities called symbols. Examples of symbols are 
packages, classes, functions, parameters or variables. A symbol can have a name, or can be anonymous. 
Symbols can be introduced using syntactic constructs called declarations, or be implicitly declared. Every 
symbol that is not a package can have at most one declaration. A package can have one or more 
declarations.

=== Declaring Symbol
Every symbol (except TODO?) has exactly one declaring symbol. Usually, the declaration of a symbol is 
immediately textually contained within the declaration of its declaring symbol. For example, the 
declaring symbol of a method is the class in which it is declared, and the declaring symbol of a 
parameter is the method in which signature the parameter occurs. Sometimes, but not always, a symbol 
is a member of its declaring symbol. In the previous example, the method is a member of its declaring 
class, but the parameter is not a member of its declaring method.

=== Implicit Declarations
TODO: What symbols can be declared implicitly (e.g. default constructor, or `it` parameter in lambdas, `field` in accessors).

=== Modifiers
Syntax for some declarations allow to provide a modifier list, that may contain zero or more modifiers.
Each declaration kind can have it own rules governing allowed modifiers and valid combinations of them,
but general rules are given in this section.

A modifier is one of the following keywords: 

abstract
annotation
companion
crossinline
data
enum
external
final
in
infix
inline
inner
internal
lateinit
noinline
open
operator
out
override
private
protected
public
reified
sealed
tailrec
vararg

Among those, only `in` is a hard keyword, all others are soft keywords that are reserved only in a modifier position.

An order of modifiers in a modifier list is not significant. The same modifier cannot appear more then once in the 
same modifier list. Modifiers `public`, `private`, `protected` and `internal` are called _visibility modifiers_, they are used
to specifity a visibility of a declared symbol. Only declarations of type members can have protected modifier.

The following pairs of modifiers are incompatible: final open, final abstract, final sealed, sealed open.
Modifier open is redundant if abstract is specified. Modifier abstract is redundant if sealed is specified.

=== Visibility
Every symbol has an associated visibility domain – a region or regions of program text where it could 
be referenced from explicitly or implicitly. Explicit reference to a symbol involves a textual usage of its 
name (at least short name), while implicit does not. Every case that constitutes an implicit reference to a 
symbol is explicitly called out in the specification. [Example: Declaration of an implicitly typed local 
variable whose type T is inferred from its initializer constitutes an implicit reference to the type T. End 
Example] The visibility domain of a symbol S is the intersection of the visibility domain of its declaring 
symbol and the declared visibility of the symbol S. In case S does not have a declaring symbol, its 
visibility domain is just its declared visibility.

==== Declared Visibility
The declared visibility of a symbol is determined by a visibility modifier present at the symbol 
declaration, if any. 

=== Packages
All declarations in program are grouped in packages. Different packages can have declarations with the same
simple name that helps to avoid name clashes. A package name is a sequence of one of more simple names
separated by dots. There is also a default package that has no name.

TODO: define "module"

A single module can contain multiple packages, and symbols in the same package can be declared in different
modules. Declarations in a single file introduce symbols in the package specified in the package directive in
the file header. If a file contains no package directive, the declarations in this file introduce symbols
in the default package.

=== Classes
TODO

=== Interfaces
TODO

=== Generics
TODO: Give a concise description of generic types, with a reference to detailed specification in §?.

==== Type Parameters
TODO

==== Declaration-site Variance
TODO

==== Type Projections
TODO
A type projection cannot be used as a supertype.

=== Nullable Types
TODO
Regular reference types (classes, interfaces and arrays) do not support null value. The language 
guarantees that all variables of those types are initialized with a valid object reference prior to their use, 
and expressions of those types evaluate to a valid object reference (if their evaluation completes 
normally). Type parameters can be instantiated both with non-nullable and nullable types (unless their 
bounds indicate otherwise), so the compiler must handle them conservatively: it does not allow 
assigning null value to variables whose type is a type parameter (because it may be instantiated with
a non-nullable type), but when reading from them, it cannot assume that the value is not null unless it can
be proven via static data-flow analysis (because it also may be instantiated with a nullable type). Every reference 
type, type parameter or a primitive type T has a corresponding nullable type T?. The type T is called the 
underlying type of the nullable type T?. It is valid (but completely redundant) to write T?  even if T is 
already a nullable type. A nullable type can have any value as its underlying type plus an additional null 
value. The null value is denoted using the keyword null. The type kotlin.Nothing? has the only 
value null and is a subtype of every nullable type. The type kotlin.Any? can store any value 
whatsoever, and is a supertype of any nullable and non-nullable type. The type of the null literal is 
kotlin.Nothing?.
TODO: Say more about instantiation of type parameters.
A nullable type cannot be specified as a supertype. A nullable type cannot be used on the left hand side 
of dot (in type or expression), except as a receiver type in extension functional types.

TODO: It looks reasonable to support a non-nullable version T! of type parameter T that is not known to be
non-nullable. If the type parameter T is instantiated with a non-nullable type then T! is the same type as T.
Otherwise, the type parameter T is instantiated with some nullable type S?, and T! is the same type as its
underlying type S. Non-nullable versions of type paramerers can be propagated into parameters of lambdas
by smart casts.

=== Primitive and Special Types
A primitive type is usually represented by the platform as a fixed-length bit pattern, and can be directly
and efficiently manipulated by the hardware. But the language does not prescribe any particular representation
for primitive type, but only requires that their observable behavior corresponds to the following descriptions.
Primitive values do not have simpler components representable in the language, do no share any state with other 
primitve values and are effectively immutable. [Note: Individual bits of integer types can be extracted using
bitwise operations, see §?. End Note]

 * Boolean -- a boolean type having exactly two values, represented by literals true and false.
 * Byte -- a signed (2-complement) 8-bit integer type.
 * Short -- a signed (2-complement) 16-bit integer type.
 * Int -- a signed (2-complement) 32-bit integer type.
 * Long -- a signed (2-complement) 64-bit integer type.
 * Char -- unsigned 16-bit integer type, intended to represent UTF-16 code points.
 * Float -- a single-precision 32-bit IEEE 754 floating point type.
 * Double -- a double-precision 64-bit IEEE 754 floating point type.

Due to different representations, smaller types are not subtypes of bigger ones. Kotlin supports the 
standard set of arithmetical operations over numbers, which are declared as members of appropriate 
classes (but the compiler optimizes the calls down to the corresponding instructions).

==== The kotlin.Any Type
All classes in Kotlin have a common ultimate superclass kotlin.Any. kotlin.Any is the default superclass
for a class with no superclass declared. Any is not java.lang.Object, in particular, it does not have any members other 
than methods equals(), hashCode() and toString(). It is the root on the hierarchy of all non-nullable 
types. To declare a variable that can store a reference to a value of any type (nullable or not), the nullable type 
kotlin.Any? can be used.

All interfaces are considered to be subtypes of kotlin.Any.

kotlin.Any has the following parts:

public constructor()
public open fun equals(other: Any?): Boolean
public open fun hashCode(): Int
public open fun toString(): String

The constructor implementation is an empty block that does nothing.

The default implementation of the method equals performs reference equality check. It can be overridden in derived
types to implement a custom equality behavior. It is strongly recommended that any implementation of this method
satisfies the following rules:

 * Termination. The method shall complete normally (i.e. it shall not go into an ininite loop or throw an exception).
 * Purity. An invocation x.equals(y) shall not change any observable state of objects x and y (it may update some caches though).
 * Reproducibility. Multiple invocations x.equals(y) shall return the same result (unless state of either x or y has 
   changed in between).
 * Reflexivity. For any non-null value x the expression x.equals(x) shall return true.
 * Symmetry. For any non-values x and y expressions x.equals(y) and y.equals(x) shall return the same value (unless state
   of either x or y has changed in between).
 * Transitivity. Invocations x.equals(y) and x.equals(z) shall return the same value if y.equals(z) returns true (unless 
   state of either x, y or z has changed in between).

Many functions from the standard library may produce unexpected results if any of these rules is violated. It is reasonable
to expect implementations of the equals method to be conformant to these rules when writing library code, but one should
not rely on it when reasoning about code security and other critical properties, because a malicious client
could exploit it and create a security breach.

The default implementation of the hashCode method returns a hash code for the current object, consistent with the behavior
of the equals objects (i.e. equal objects always have the same hash code).

TODO: toString method

==== The kotlin.Nothing Type
The type kotlin.Nothing is an uninhabited type (i.e. no value can have this type at runtime). Consequently, 
an evaluation of an expression of type kotlin.Nothing never completes normally (for 
example, it may be a non-terminating computation, may throw an exception, or result in a control flow 
transfer). The type kotlin.Nothing is a subtype of every other type. The corresponding nullable type 
kotlin.Nothing? can have the only value null. Neither kotlin.Nothing nor kotlin.Nothing? 
can be used as a reified type argument.

==== The kotlin.Unit Type
The kotlin.Unit is a singleton type whose directs superclass is kotlin.Any. It does not implement any interfaces.
It does not have any members beyond those inherited from kotlin.Any. The expression kotlin.Unit represents
the single instance of the kotlin.Unit type. This type may be used as a return type of any function that does
not return any meaningful value.

==== The kotlin.Byte Type
TODO

==== The kotlin.Short Type
TODO

==== The kotlin.Int Type
TODO

==== The kotlin.Long Type
TODO

==== The kotlin.Char Type
Represents a UTF-16 code point, rather than a Unicode character. Some Unicode characters are represented by a pair of
surrogates, each of them is a separate instance of the kotlin.Char type.

TODO

==== The kotlin.Float Type
TODO

==== The kotlin.Double Type
TODO

==== The kotlin.Boolean Type
The type Boolean represents Boolean values. It has exactly two possible values: true and false.
TODO

==== The kotlin.Array<T> Type
The kotlin.Array<T> represents a flat array of elements of type T. Unlike other classes whose constituent values are
stored in fields, an array's constituent values are its elements. Unlike classes that specify number of their fields
in their declarations at compile-time, an array type does not specify the number of its elements. This number is
specified when a particular instance of an array is created, and remains unchanged for the lifetime of that instance.

All elements of an array are effectively public, and can be read or updated by any code that has access to the array itself.

When kotlin.Array<T> is used with primitive types, its elemements are stored in boxed form, that might not be very efficient.
For flat array of primitive types, the standard library provides non-generic types ByteArray, ShortArray, IntArray, LongArray,
CharArray, BooleanArray, FloatArray, DoubleArray. These classes have no inheritance relation to the Array<T> class, but they have
similar characteristics and similar set of methods and properties.

==== kotlin.String class
Values of the class String are strings, i.e. finite immutable sequences of UTF-16 code points. A string can have zero or more
code points (their length is limited only by platform or available memory). Strings are immutable, meaning that neither their
lengths, nor any of their elements can be modifier after their creation.

==== The dynamic Type
The type dynamic may be supported not on every platform. A supertype cannot be the dynamic type.
TODO: Subtyping relationships for dynamic.


=== Functional Types
There are two kinds of functional types: free functional types and extension functional types. A free functional
type specifies zero or more parameter types, and a return type. An extension functional types in addition specifies
a receiver type.

If a function does not return any meaningful value (for example, is invoked for the sake of its side effects), 
it may be declared with kotlin.Unit return type. If a function never returns normally (for example, contains an
infinite loop, always throws an exception, or terminates the process), it mat be declared with kotlin.Nothing return type.

TODO: Mapping of functional types to named types.

=== Platform Types
TODO

=== Type Relationships
It is possible that two types having different syntax forms are considered equivalent (even ignoring the possibility
of fully qualified names and name aliases). In particular:
 * Nested nullable types (e.g. String??) are equivalent to the corresponding single nullable types (e.g. String?). 
 * Star-projection is equivalent to the corresponding out-projection (or, in contravariant case, G<Nothing>).
 * Functional types are equivalent to corresponding named types.

TODO: Type equivalence, inheritance, subtyping, interface implementations.

==== Restrictions
An inheritance hierarchy shall be acyclic, that is more precisely described by the following rule.
Construct a directed graph, where all declared types in the program (classes, interfaces, objects) are represented by vertices,
and there is an edge from type A to type B if the declaration of A lists B among its supertypes (ignoring type arguments) or
if type A is nested within type B. It is an error if the constructed directed graph contains a cycle. It means, for example,
that it is an error for a class to inherit from itself, or for two classes to inherit from each other, or for a class to
inherit from its nested class.

It is syntactically impossible for a top-level class to specify a local class as its superclass.

==== Single Instantiation Rule
It is an error if the transitive closure of supertypes of a type contains two different instantiations of a generic type.
TODO: do we permit any flexibility for variant types?

TODO: no expanding generic graphs, single instantiation inheritance.

=== Properties and Fields
TODO

=== Methods and Functions

==== General
A function is a callable fragment of code that may have parameters, return value and a set of local 
variables. Each invocation of a function creates a separate copy of parameters and local variables, 
independent from other invocations of the same function, usually referred to as a logical stack frame. A 
logical stack frame can be different from a physical stack frame because of tail call optimizations, inlining 
and other reasons. Lifetime of some parameters and variables can follow special rules if they are captured in 
a closure (§Closure).

Evaluation of a function can cause an invocation of another function (or a recursive invocation of the 
same function) that effectively suspends evaluation of the current function, pushes a new frame to the 
call stack, and transfers control flow to the beginning of the body of the callee. If evaluation of a 
function completes normally, the topmost stack frame is discarded, and control flow (and, possibly, a 
return value) is returned back to its caller, and its evaluation is resumed at the point immediately 
following the invocation (the return value, if any, becomes the value of the completed invocation 
expression). Evaluation of a function can also result in an exception (§Exception), which can be either 
caught and handled inside the same function, or result in an abrupt completion of the function, and 
propagation of the exception along the stack to a closest direct or indirect caller that can catch and 
handle it.

Functions can be either named or anonymous (lambdas). Named functions can be either top-level 
functions, local functions or member functions (methods).

==== Parameter List
Names of all type parameters in a type parameter list must be distinct. Names of all formal parameters 
in a formal parameter list must be distinct. A name of a formal parameter in a formal parameter list 
cannot be the same as a name of a type parameter in a type parameter list associated with the same 
function.

TODO: type parameter list, parameter list.

==== Generic Methods
TODO

==== Local and Top-Level Functions
TODO

=== Parameters
TODO

=== Locals
Read-only local variables are declared using val keyword. Mutable local variables are declared using 
var keyword.

=== Singleton Objects
An object declaration inroduces two symbols of different kinds, but with the same name: a class
and a value that is the only instance of that class. The class is cannot be inherited from and is guaranteed
to have exactly one instance. Unless specified otherwise, object declarations follow the same rules as
class declaration. An object declaration can specify a superclass and zero or more superinterfaces.
An object declaration cannot have type parameters or access type parameters from an outer scope.
An object declaration can have the following modifiers: companion final internal private protected public.
An object declaration cannot be inner, open or abstract. Although the final modifier is allowed, it is
redundant on object declarations. An object declaration can have no constructors. An object declaration
cannot be local, or be enclosed in a local class declaration. An object declaration can be top-level
or be declared within a class declaration, an interface declaration, or an object declaration (but not within
a companion object declaration). An object declaration cannot access this instances of enclosing types.

Singleton objects are initialized in an order determined by their dependencies. In case of an initialization
loop it is possible to observe a value of an object in a loop as null. It can cause an exception if this
value is passed to a function expecting a non-nullable type. [Example:

abstract class A(val x : Any?)
object B : A(C)
object C : A(B)

fun main(args: Array<String>) {
    println(B.x)
    println(C.x) // null
}

End Example]
TODO

==== Companion Objects
Companion object may be declared within classes or interfaces, including generic ones. An optional name
can be specified for a companion object, if no name is 
specified, the default name Companion is used. The name of a companion object (explicit or default) 
must be distinct from names of other members declared in the containing type. No more than one 
companion object per class or interface are allowed. When the name of a companion object is accessed 
through dot on the name of the containing class or interface, no type arguments can be provided to the 
containing type name, even if the type is generic. A companion object can specify a super class and zero 
or more superinterfaces. A supertype can be the containing type of the companion object (if the 
containing type is generic then type arguments must be provided, but they cannot use type parameters 
of the containing type). The body of a companion object is optional, if a body is not provided, an empty 
body { } is assumed. Members of a companion object can be accessed directly through the dot on its 
containing type name (no type arguments must be provided even if the containing type is generic). The 
name of a companion object hides its identically named members in this context (the hidden members 
are still available by lookup in the name of the companion object in this case). TODO: This hiding 
behavior is actually not that simple for method names. 

A type and its companion object have access to private members of each other, regardless of declared
visibility of the companion object.

If a companion object is declared within a generic type, so that multiple instantiations of the generic
type is possible, there is still only one instance of a companion object. Type parameters of containing
types are not available in the declaration of a companion object.

Companion objects cannot be declared within local or inner classes.

Declared visibility `private` or `protected` of members of a companion object is understood with respect
to its container type rather than the companion object itself (TODO: implementation bug with protected).

TODO: What does it mean for a companion object to be private.

TODO: The name of a containing type can itself be used as an expression that refers to the companion object.

==== Labels
Certain locations in code can be named for later reference by declaring labels.

TODO: Declaration space and scope for labels

* Implicitly Declared Labels
TODO

== Values and Types

=== General
A value can be a reference to an object, a null value (a special value distinct from a reference to any object) or a primitive value.
For primitive values, an implementation can choose in each case (for performance or other reasons) whether a variable stores
a primitive value directly, or stores a reference to a boxed copy of a primitive value -- the language does not provide any means
to force either behavior. There can be multiple references to the same boxed instance, and there can be multiple boxed copies of
the same primitive value. A result of the reference equality operator for primitive types is unspecified.

The null value is a special immutable structureless value. Its exact type is Nothing? (it's the only value of this type), and it
also belong to every nullable type, usually indicating an absence of any valid value of the corresponding non-nullable type.

TODO: Move detailed discussion of arrays to corresponding section?

An object is either an instance of a class, or an instance of an array type. An array type is either generic class Array<T> or
one of the types representing arrays of primitives: 
 * BooleanArray -- an array of values of type Boolean
 * ByteArray -- an array of values of type Byte
 * ShortArray -- an array of values of type Short
 * IntArray --  -- an array of values of type Int
 * LongArray -- an array of values of type Long
 * CharArray  -- an array of values of type Char
 * FloatArray  -- an array of values of type Float
 * DoubleArray  -- an array of values of type Double

Arrays are different from classes with respect to how they store their data. A class always have a fixed number of storage locations
named fields, and each field can have its own type, and each instance of than class will have that fixed number of fields. If one
needs an object with a different number of fields, it is necessary to declare a new class. An array type, on the other side, only
defines a type of its storage locations named elements, but leaves their number undefined. The number of elements of an array
is specified only at runtime when a particular instance of an array is created (it can be zero or more, and is limited only by platform
or available memory). It remains constant during existence of that particular instance, but can be different for different instances
despite that they all belong to the same array type. Also, unlike fields of a class instance that can be declared immutable and
therefore their values cannot be changed after the instance is created, all array elements are always mutable. A fieldis referred to
by its name (or, indirectly, by a name of the corresponding property), but an array element is referred to by its index. An index indicates
an offset from the first element of the array (so that the first element has index 0, the second element has index 1, and so on
to the last element of an array that has an index equal to the length of the array minus one). This is so called zero-based indexing.
Indices less than 0, or greater or equal to the length of the array are invalid, and an attempt to access an element by such an index
will result in an exception (WHICH?) at runtime. An array of length 0 is called an empty array, and is has no valid indices -- any
attempt to access its element results in an exception.

TODO: Sort out terminology: we say that Array<T> is a class, but make a distinction between array instances and class instances.

Each value has a type. A type is an abstraction capturing common properties (e.g. a set of supported operations and some information
about their possible results) of a family of similar values. While exact values of expressions are usually known only at runtime
(except constant expressions that are fully evaluated at compile time), types can be known at compile time, so the compiler can reason
about them, and guarantee certain desirable properties of a program (e.g. that a certain method is never invoked on an object that
does not support it).

Values and types are distinct notions and they do not mix (unlike in some programming languages featuring dependent types). Nonetheless,
some types can be described using values of type KClass<T>, and their properties can be queried at runtime, using a technique
called reflection. It is important to remember that those values are not types, they just describe or represent types.

Each value has a single exact type. This is the narrowest type representable in the language, to which the value belongs.

A type can also be thought as representing a set of all possible values having this type. If a type A represents a subset of values,
represented by a type B, the type A ...

TODO: only subtyping defined by rules

TODO: exact type, reflection and erasure

=== Syntax for Types
TODO
A type can be parenthesized, it does not change its meaning.

=== Compile-time and Run-time Types
TODO

=== Reified Types
A captured type argument cannot be used as a reified type parameter. The type kotlin.Nothing 
cannot be used as a reified type parameter.

TODO

=== Conversions
TODO



== Control and Data Flow

=== General
TODO

=== Definite Assignment
Every local variable must be definitely assigned at every point in reachable code where its value is read.

TODO: Exact rules.

TODO: Definite assigment for properties

=== Smart-casts
The language uses information about preceding checks for null, checks for types (is, !is), safe call operators (?.)
and Nothing-returning expression to infer additional information about types of variable (beyond that explicitly
specified or inferred from initializers at their declarations) that may be more specific in certain blocks or
even expressions. This information is then used to enable wider set of operations on those expressions and to
select more specific overloads.

TODO: Desctiption of the algorithm.

Example of code not handled by the algorithm (https://youtrack.jetbrains.com/issue/KT-8781):

fun f(x : Boolean?, y : Boolean?) {
    if (x == true) return
    if (x == false) return
    if (y != x) {
        y.hashCode()
    }
}

=== Unreachable Code
Certain regions of code may be proved unreachable via static analysis, which results in a compile-time 
warning. Definite assignment is not checked within unreachable code, and assignment in unreachable 
code has no effect of definite assignment state of variables. Otherwise, unreachable code is not exempt 
from rules of this specification, and any violations result in errors in the same way as in reachable code. 
Compiler is free to skip code generation for any code proved to be unreachable, but it should not have 
any observable effects (not counting direct inspection of the binaries).

TODO

==== Effects of kotlin.Nothing Type
An evaluation of expression of type kotlin.Nothing never completes normally, and any assignment 
to a variable of type kotlin.Nothing is unreachable.

TODO

==== Effects on Nullability
TODO

==== Effects on Smart-Casts
TODO

==	Application Life Cycle

=== Applications vs. Libraries
TODO

=== Application Startup
TODO

=== Entry Point
TODO

=== Type Loading and Initialization
TODO

=== Threads 
TODO

==== Race Conditions
TODO

=== Unhandled Exceptions
TODO

=== Runtime Limitations

==== General
TODO

==== Stack Overflow
TODO

==== Out of Memory Condition
TODO

=== Application Termination
TODO

=== Garbage Collection
TODO

=== Finalization
TODO




== Object-Oriented Programming Features

=== General
TODO

=== Inheritance
TODO

=== Interface Implementation
TODO

=== Visibility
TODO

=== Overriding
In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many 
implementations of the same member from its immediate superclasses, it must override this member 
and provide its own implementation (perhaps, using one of the inherited ones). To denote the 
supertype from which the inherited implementation is taken, we use super qualified by the supertype 
name in angle brackets, e.g. super<Base>.

If a member is overridden on one inheritance path, it’s considered to be overridden on all inheritance 
paths.

TODO

=== Delegation
TODO

=== Extension Members
If a member function in type A is an extension for type B, then in case it’s invoked with an explicit 
receiver, it must be of type B.

TODO

=== Object Construction
TODO

=== Runtime Virtual Invocation Dispatch
TODO

=== Singleton Objects
Kotlin has a predefined syntax to declaring singleton objects.

TODO




== Functional Programming Features

=== General
TODO

=== Functional Values
TODO

=== Method References
TODO

=== Anonymous Functions
TODO

==== Lambda as an Argument to an Invocation
TODO: Special syntax

=== Function Inlining
TODO

==== inline Functions
An inline function is declared with the annotation inline. Any of type parameters of an inline functions 
can be made reified by declaring them with reified modifier. A virtual function (i.e. non-private, non-
final method) cannot be declared inline. An inline function cannot be directly recursive (it also cannot 
invoke itself inside nested lambdas, and cannot have a callable reference to itself). An inline function 
cannot be indirectly recursive if in at least one recursion cycle all functions are inline. 

Currently following declarations and expressions are not supported anywhere inside inline functions 
(including any nested object expressions):
*	declarations of local functions
*	declarations of local classes and interfaces
*	function expressions (starting with fun keyword)
*	default values for optional parameters

Currently a local function cannot be declared inline.

If an inline function has a parameter of a functional type without noinline annotation, and an 
argument corresponding to this parameter is an anonymous function (function expression or function 
literal), then this anonymous function is inlined at each of its usages in the body of the inline function 
(which is itself is inlined at its call site). The function literal is allowed to have non-local return 
statements in such cases. There are also certain restrictions on use of such parameters: they cannot be 
assigned to variables, fields, properties, or array elements or passed as arguments to non-inline 
functions (or arguments to inline functions that are not inlined, e.g. have non-functional declared type, 
vararg modifier, or noinline annotation). Unless they are annotated with an annotation 
inlineOptions (InlineOption.ONLY_LOCAL_RETURN), they cannot be used within function 
literals or object expressions.

Parameters of an inline function that has nullable functional types must have noinline annotation.
TODO

==== Non-local Control Flow Transfers
TODO

=== Closures
TODO

==== Instantiation and Lifetime of Captured Variables
TODO

==== Implications for Strong References and Garbage Collection
TODO

==== external Modifier
external modifier is only applicable to top-level functions. Top-level function mush have a body unless it is external.
External function cannot be inline. External function cannot have a body. If function is not external and not 
abstract, it must have a body. A constructor cannot be external.

TODO: external accessors?

==== tailrec Modifier
tailrec modifier on a function indicates that that a function is tail-recursive and its recursive invocations must be
optimized by the compiler to loops. If tailrec modifier is applied to a function that is not actually tail-recusive,
a compile-time error occurs.





== Compilation Units

=== General
TODO

=== File-Level Annotations
TODO

=== Package Specification
If a package specification is present, it should be at the top of the source file. It is not required to match 
directories and packages: source files can be placed arbitrarily in the file system. All the contents (such 
as classes and functions) of the source file are contained by the package declared. If the package is not 
specified, the contents of such a file belong to the default package that has no name.

TODO

=== Import Directives
Apart from the default imports declared by the module, each file may contain its own import directives. 

An import directive must refer to a fully qualified name
It is an error if two import directives attempt to import types with the same simple name. If several import
directives import the same type multiple times, redundant imports are ignored and the result is the same as if
the type was imported only once.

It is an error if two import directives import different symbols but attempt to rename them to the same name. 
If several import directives import the same symbol multiple times and rename it to the same name N, redundant imports
are ignored and the result is the same as if the type was imported by the name N only once.


===	Type and Object Declarations
TODO

=== Package-Level Functions
Function visible from outside of a module should have return type explicitly specified. Unit return type 
can be omitted.

TODO


== Classes

=== General
A class is a nominal type that is a complete or partial template describing object shape and behavior. It
can encapsulate state, object initialization logic, public functional contract, possibly providing a
complete or partial implementation of it and an implementation of private functional members it may have.
A class can be introduced via a class declaration, object declaration or anonymous object expression.
Classes introduced via class or object declarations are named (their names always occur explicitly in
their declarations, except for companion objects that are allowed to omit it and use a default name). Classes
introduced via anonymous object expressions do not have a denotable name, but still behave as nominal (not
structural) types.

=== Class Declarations
A class declaration can appear at the top level, 

A body of a class, interface or object declaration is optional. If no explicit body is provided, then an 
empty body {} is assumed.

TODO

=== Class Modifiers
A class can have zero or more of the following modifiers: visibility modifiers and `abstract`, `enum`, `final`,
`inner`, `open`, `sealed`. 

An order of modifiers is not significant. The same modifier cannot appear more then once in the same modifier
list. Not all combinations of modifiers are valid and not all modifiers are allowed on all class declarations.

A modifier list can contain no more than one modifier from the set: public private protected internal. Only
member classes can have protected modifier.

The following pairs of modifiers are incompatible: final open, final abstract, final sealed, sealed open.

Modifier open is redundant if abstract is specified. Modifier abstract is redundant if sealed is specified.

TODO: factor out the common rules for modifiers and visibility modifiers into a separate section.


=== Initialization Blocks
Initialization block appears within a class body and must be immediately preceded by the init 
contextual keyword. Initialization block is not a declaration and so does not introduce a symbol. It is 
evaluated during the primary constructor invocation. A class can have multiple initialization blocks, 
they are evaluated in their textual order. Primary constructor parameters are in scope throughout all 
initialization blocks of the class. Variables declared in one initialization block are not in scope in other 
initialization blocks of the same class.

Initialization blocks can also appear in object declarations and object expressions. They are evaluated during
the initialization of the corresponding object in their textual order.

Annotations on init blocks?

TODO

=== Class Members
Non-abstract classes cannot declare abstract functional members (but can have abstract member 
classes), and must override all inherited abstract functional members.
TODO

=== Constructors
A class in Kotlin can have a primary constructor and one or more secondary constructors. The primary 
constructor is declared in the class header: it goes after the class name (and optional type parameters). 
Keywords val and var together with accessibility modifiers can be applied to primary constructor’s 
parameters to implicitly declare and initialize properties with the same names. They also can have
override modifier to override properties from a supertype. The primary constructor 
cannot contain any code. Initialization code can be placed in initializer blocks, which are prefixed with 
the init. Note that parameters of the primary constructor can be used in the initializer blocks. They can 
also be used in property initializers declared in the class body.

The class can also declare secondary constructors, which are prefixed with constructor. If the class has a 
primary constructor, each secondary constructor needs to delegate to the primary constructor, either 
directly or indirectly through another secondary constructor(s). Delegation to another constructor of the 
same class is done using the this keyword.

If a non-abstract class does not declare any constructors (primary or secondary), it will have a default 
primary constructor with no arguments. The visibility of the constructor will be public. In order to avoid 
creating a default constructor, an empty private constructor can be declared.

If the class has a primary constructor, the base type can (and must) be initialized right there, possibly 
using the parameters of the primary constructor.

If the class has no primary constructor, then each secondary constructor has to initialize the base type 
using the super keyword, or to delegate to another constructor which does that. Note that in this case 
different secondary constructors can call different constructors of the base type.

It is an error to access this of the object being created in a constructor delegation. (TODO: access to members 
or super access).

A class cannot have two or more constructors with the same signature. The @platformName annotation is 
not applicable to constructors.

Constructor cannot have type parameters, and there is no way to provide type arguments to the 
constructor itself at a constructor invocation.

Cycles in constructor delegation are not allowed.

Constructor body is optional, if no explicit body is provided then an empty body { } is assumed. 
Constructors cannot have an expression body.

A constructor can have only visibility modifiers.

A constructor declaration in class C introduces a method with name C in the same declaration space where
the class C is declared. Such method can overload other methods in the same declaration space (possibly
including other constructor) subject to normal overloading rules. Such methods cannot override methods
from supertypes.

this of the current class is not available in a superclass constructor invocation.

TODO

=== Methods
Functions that declared as members of a type are called methods.

TODO

=== Properties
A property is a functional member that is syntactically accessed like a variable, but can be implemented either
a simple storage location, or using custom code that is executed when the property is read on written. A
property can be read-only or read-write. A readonly property has a single accessor called getter, and
a read-write property has a pair of accessors called getter and setted. An accessor is a function that is invoked
when the corresponding property is accessed: a getter is invoked on property read, and a setter is invoked or
property write.

A property can have a underlying storage location called a backing field. Within accessor bodies, the backing field
is a available as a variable named `field`. The identifier field is not a reserved keyword, and has a special 
meaning only within property accessors, and even there can be shadowed according to regular rules. No code outside
of a property accessors can name or otherwise access the backing field of the property. The type of the backing field
is the same as the type of the property.

The backing field exists if at least one accessor is default (non-abstract, non-external and does not have a body) or
at least one accessor refers to the backing field using `field` identifier.

==== General
Classes in Kotlin can have properties. These can be declared as mutable, using the var keyword or read-
only using the val keyword.

==== Properties without Explicit Accessors
Non-abstract properties must have an initializer.

TODO

==== Properties with Explicit Accessors
The full syntax for declaring a property is
var <propertyName>: <PropertyType> [= <property_initializer>]
  <getter>
  <setter>
The initializer, getter and setter are optional. Property type is optional if it can be inferred from the 
initializer or from the base class member being overridden. Types are not inferred for properties 
exposed in the public API, i.e. public and protected. If you need to change the visibility of an 
accessor or to annotate it, but don’t need to change the default implementation, you can define the 
accessor without defining its body.

TODO

=== Fields
Classes cannot declare fields explicitly. But there is an implicitly declared field for every non-abstract 
property. It can be accessed using the $ symbol followed by the property name (it’s a single token, so no 
whitespace is allowed in between). A field has private-to-this accessibility, and can only be accessed 
from inside the class where the corresponding property is defined. 

TODO

=== Nested and Inner Classes
Inner classes are nested classes declared using inner modifier. Inner classes cannot be declared within 
interfaces or non-inner nested classes. Inner classes may not contain nested interface declarations or 
non-inner nested class declarations. Inner classes have access to current instances of their enclosing 
classes.

TODO

/* END OF CLASS MEMBER DESCRIPTION */

=== Local Classes
A local class is a class declared within a block. A local class cannot have inner modifier. Local classes 
may not contain nested interface declarations or non-inner nested class declarations. Local classes have 
access to current instances of their enclosing classes. If a local class is declared within a generic method, 
then the method’s type parameters are in scope in the local class. A local class is only in scope in its 
containing block from the beginning of its declaration to the end of the containing block (so, it’s in scope 
throughout its own declaration, and not in scope before its declaration). Local classes has access to 
outer local variables and parameters. 

TODO: specify capture semantics, compare with lambdas

=== Anonymous Classes
Anonymous classes are implicitly declared using anonymous class creation expressions (§18.3.10). The 
body of an anonymous class is the block of the corresponding anonymous class creation expression. 

TODO: Choose what do describe here and what is in the expressions’ section.

=== Enum Classes
An enum class is declared by speicifying enum modifier on a class declaration. A body of enum classes have a 
syntactic shape (TODO: reference to grammar production) different from regular classes, that is 
described below. The enum modifier is valid only on class declarations. The enum modifier cannot be 
specified more than once on the same declaration (TODO: Implement). An enum class cannot be an 
inner or local class. It cannot be a data class (TODO: Implement). It cannot have open modifier and 
other classes cannot inherit from it, except classes corresponding to entries of the same enum class, 
that always implicitly inherit from it. It cannot have abstract modifier, and is always implicitly 
abstract. It cannot have annotation or sealed modifier (TODO: Implement). It can have data 
annotation (TODO: bug?). An enum class declaration cannot have type parameters (and because it 
cannot be inner or local, it does not have any type parameters in scope at all).  An enum class 
declaration cannot specify an explicit superclass, but it can specify superinterfaces. The direct 
supertype of an enum class E is assumed to be Enum<E>. [Note: As a consequence of the single 
instantiation inheritance rule (§TODO), if an enum class type E explicitly implements an instantiation of 
interface Comparable<T>, it must be Comparable<E>, because this instantiation is implemented by 
its supertype Enum<E>. End Note] An enum class can have a companion object.

A constructor of an enum type cannot be invoked explicitly, it can only be implicitly referenced from the 
declaration of an entry of the same enum. The argument list can be omitted if empty. Trailing lambda, if 
any, must be provided as a regular explicit argument.

Each enum entry must have a unique name within declaring enum class. An enum entry cannot have visibility
modifiers and is implicitly public. Each enum entry name occupies a slot in the enum member declaration space.
A secondary constructor cannot delegate to a constructor of the superclass.

An enum entry cannot have a companion object. An enum entry can have init blocks. An enum entry 
cannot have constructors. It cannot specify superinterfaces.
Enum classes cannot have abstract modifier, but are implicitly abstract. If an enum class  
contains at least one abstract functional member, then each its entry must 
provide implementation for all abstract functional members.

Synthetic functions valueOf(value: String), values() and special overload resolution rules for them
(including possible conflicts with identically named functions of a companion object).

TODO: this and super in enum entries.

=== Data Classes
A data class is a class declared with a `data` modifier. A data class is always final. It is permitted, but not required to specify
a `final` modifier on its declaration. A data class cannot specify its superclass, but can specify zero or more superinterfaces.
The direct superclass of a data class is always Any. A data class cannot be inner class, but can be local. A data class can contain
inner classes.

A data class must have a (TODO: public?) primary constructor that has at least one parameter. All primary constructor parameters
must be val/var.
A data class cannot have `enum`, `annotation`, `abstract`, `open`, `sealed` modifiers.

A data class provides default implementation for equals, hashCode and toString method. If a declaration of any of these methods is
provided explicitly, then it replaces the corresponding default implementation.

The default implementation for equals method performs first performs reference equality check for `this` and its arguments, and if
this check returns true, then the equals method returns true. Otherwise, it performs component-wise comparison using == operator in
the same order in which the components are declared. If any of the comparisons returns false, the method immediately returns false. 
Otherwise, if all comparisons return true, then the method returns true. [Note: It is possible that this implementation goes into an
infinite recursion if a component of a data class is (or refers to) the current instance. End Note] Components that are arrays are
compared like all other types using array's equals method (that performs reference equality comparison). [Note: If structural comparison
is desired then it's recommended to manually implement equals method using java.util.Arrays.equals or java.util.Arrays.deepEquals and
provide a mathing implementation of hashCode(). End Note]

TODO


== Interfaces

=== General
An interface represents a contract than can be implemented by multiple classes, and a class can implement multiple interfaces.
An interface can also specify zero or more superinterfaces. Thus, interfaces provide a restricted mechanism of multiple inheritance.
Interfaces cannot contain any data or initialization logic, they can only declare abstract function members and optionally provide
a default implementation for some of them. An interface cannot be instantiated directly, only a class implementing this interface
can be instantiated, and an instance of such a class is also considered an instance of the interface.

An interface cannot explicitly declare a superclass. But because an instance of an interface can only exist as an instance of some class that
implements it, and every class has the class kotlin.Any as its ultimate superclass, every interface is considered to have kotlin.Any as its
only superclass, and consequently, it is assignable to that class and inherits its members (unless they are overridden by a superinterface
of this interface).

An interface method without a body can be marked abstract, but this is redundant.
=== Interface Declarations
An interface declaration cannot have an initialization block or a constructor declaration.

TODO

==== Methods
TODO

==== Properties
Properties in interfaces cannot have state, and never have an associated implicitly declared field.

TODO

=== Interfaces vs. Classes
TODO



== Annotations

=== General
TODO

=== Declarations
An annotation class is declared by specifying annotation keyword before the class keyword in a class 
declaration. It is an error if an annotation class is generic. An annotation class declaration cannot have a 
body (and so, cannot have a companion object or any members other than inherited or introduced in its 
primary constructor). An annotation class cannot specify supertypes explicitly. Their immediate 
supertype is kotlin.Annotation. An annotation class cannot be an inner class, but can be a local 
class (TODO: bug?). If no primary constructor is specified, then a primary constructor with an empty 
parameter list is assumed.

TODO

==== Primary Constructor Parameters
Parameters of the primary constructor in an annotation class must be declared with val or var 
keyword. A type of a parameter cannot be nullable type. A type of a parameter must be one of the 
following:
 *	Primitive type: Byte, Short, Int, Long, Char, Boolean, Float, Double
 *	String
 *	An instantiation or a projection of KClass<T>
 *	An enum type
 *	An annotation class
 *	An array of any of above-mentioned types, or an out-projection of Array<T> with any of above-mentioned types. 

Note: Arrays of arrays are not supported. End Note]
Default values for parameters, if any, must be expressions that would be valid arguments to an 
annotation application, and they cannot refer to other parameters.

TODO

=== Annotation Targets
A declaration of an annotation specifies to which code elements the annotation can be applied. Those code
elements are called targets. The following targets exist:
* method declaration
* type declaration
* file
* type parameter
* parameter
* TODO

If annotation targets are not specified at its declaration, it has the default set of targets: TODO
 
=== Applying Annotations
An argument to an annotation application must be a compile-time constant, a class expression, an 
annotation constructor invocation, an invocation of arrayOf(…) function. In the two latter cases, 
arguments to an invocation must be expressions that would be valid arguments to an annotation 
application.

File annotations are only allowed at the top of a source file. The import directives below them, if any, 
are still in effect for the name resolution in file annotations.

If an annotation is specified in a position where it can possibly apply to several different targets,
then the target is selected according to the list of possible targets of the annotations. If several
targets match, then the first applicable target from the following list is selected: parameter, property, field.

TODO: @-syntax and simplified syntax.

TODO: Meaning of annotations in functional types. Equality of types that differ in annotations.
An argument to an annotation application must be a compile-time constant, a class expression, an 
annotation constructor invocation, an invocation of arrayOf(…) function. In the two latter cases, 
arguments to an invocation must be expressions that would be valid arguments to an annotation 
application.

=== Retention Levels
TODO

=== Predefined Annotations Significant for Kotlin Compiler

==== General
Some annotations defined in the standard library have a special meaning for the compiler and may change
meaning of the language, including allowed syntactic shapes of some language constructs. They may cause or
suppress compiler diagnostics. Some of them have applicability constraints more strict that would follow
from their target(...) annotation.

Some predefined annotations have associated enum classes, whose values can be provided as their arguments
and change some details of their meaning.

TODO

==== annotation Annotation
TODO

==== AnnotationRetention Enum Class
TODO

==== target Annotation
TODO

==== AnnotationTarget Enum Class
TODO

==== enum Annotation
TODO: Will it be an annotation or a modifier eventually?

==== data Annotation
TODO

==== synchronized Annotation
TODO

==== strictfp Annotation
TODO

==== inline Annotation
TODO

==== noinline Annotation
TODO

==== inlineOptions Annotation
TODO

==== InlineStrategy Enum Class
TODO

==== InlineOption Enum Class
TODO

==== suppress Annotation
TODO

==== deprecated Annotation
The first parameter is intended to provide motivation and possible workarounds. Its value is not interpreted by
the compiler. The second parameter is IDE-specific.

TODO

==== volatile Annotation
TODO

==== transient Annotation
TODO

==== platfomName Annotation
TODO

==== jvmStatic Annotation


== Generics

=== General
A class, interface, function or property declaration may contain a type argument list that declares one or 
more type parameters. Such a declaration is called generic. It is an error if two or more type parameters 
in the same parameter list have the same name. The scope of type parameters extends to the entire 
symbol declaration to which they belong (including supertype list, the entire type argument list itself, 
and any fragments of the declaration that may appear to the left of it). Names of type parameters can be 
used like regular type names within their scope. (TODO: nested and inner classes) A generic type 
declaration serves as a blueprint for multiple type declaration having the same shape. A particular 
instance of a generic type is obtained by providing type arguments to its name. Type arguments are 
substituted to all occurrences of corresponding type parameters in the generic type declaration. The 
substitution is semantic rather than pure textual. For example, the name of a type provided as a type 
argument may be hidden or invisible at a particular occurrence of a corresponding type parameter, so a 
pure textual substitution of the name would result in that name being unresolved, or bound to an 
unrelated symbol. [Note: A type parameter within its scope may be used as a type argument, or 
otherwise apprear as a constituent of a type argument. End Note][Note: Generic declarations promote better 
type safety. For example, rather than having a non-generic ArrayList that can store elements of any type, 
and downcasting its elements to a particular type when they are extracted from list, we can declare a 
generic ArrayList<T> and to use its particular instantiation, e.g. List<Int> or List<String> when we need a 
list of integers or a list of strings, respectively. This way we cannot put an element of a wrong type to a 
list, and we do not need to downcast when we extract elements. End Note]

TODO: Description of generic types and methods, type substitution, scope of type parameters, type 
parameter bounds, projections and their members, skolemization (aka capture conversion), raw types, 
erasure, single instantiation inheritance rule.

=== Type Parameters
Type parameters of types and methods. Scope of type parameters, interaction with nested 
classes, interaction with local classes. Identity of type parameters, comparison of signatures, internal 
and external view of type parameters, multiple instantiations (cf. TS). Names and ordinal positions. 
Substitutions, composition of substitutions. Open and closed instantiations, instance type (type of this). 
Originating declaration. Generic arity.

A type parameter can never escape its scope – no expression can have a type containing a type 
parameter outside of its scope (this does not mean a type parameter is always denotable – it still can be 
hidden by other symbols). Thus, if a name in a code refers to a type parameter, it can never be a type 
parameter declared in a library, or even in a different compilation unit (the latter would become false if 
Kotlin ever introduced partial types).

A type parameter can only be denoted using a simple name, never using a qualified name (it means that 
if a type parameter is hidden, it is not denotable).

A type parameter name can never appear as the left hand side of a member access operator (dot), but it can appear
as a receiver type in extension functional types.

No two type parameters in the same type parameter list can have the same name. 

TODO

=== Instantiation

==== General
TODO

==== Type Argument List
Type argument list can be provided either to a generic type name to specify a type instantiation or 
projection, or to a generic method name to specify type arguments to this method. Type argument list is 
delimited by angle brackets and contain one or more type arguments separated by commas. A type 
argument can be either a type or a projection specifier. A projection specifier can only appear in a type 
argument list provided to a generic type. It’s an error if it appears in a type argument list for a method. A 
type argument list cannot contain zero arguments. In certain contexts, where no type arguments are to 
be provided, the whole type argument list, including delimiting angle brackets, are omitted.
In certain contexts a generic type can be used without providing type arguments – in this case the whole 
type argument list, including delimiting angle brackets, is omitted. It is an error to provide an empty type 
argument list: T<>. Number of type arguments provided in a generic type instantiation must match 
generic arity of the generic type. It is an error to provide a type argument list to a non-generic type. It is 
an error to provide a type argument list to an identifier that does not denote a type or a method. [Note: 
certain keywords (e.g. super) allow to specify a type enclosed in angle brackets that may look similar to 
a type argument list, but those syntax constructs are not type argument lists. End Note]

TODO: Discuss nested types.

=== Substitution
TODO

=== Bounds
A type parameter can have zero or more bounds. A bound is a type that can possibly depend on the type parameter
itself, or on other type parameters from the same type parameter list, or on other type parameters from an outer
scope).

A bound for a type parameter can be specified at its declaration after a colon (so called primary bound).
Also, one or more bounds can be specified in a where clause. Bounds in a where clause can be specified even if
primary bound is not present. Order of bounds is not important, except that the leftmost bound is used to
determine erased signature on platforms supporting erasure (that can result in a signature clash, for example).

A type parameter cannot specify itself as its own bound, and several type parameters cannot specify each other
as a bound in a cyclic manner. More precisely, for each type parameter list, construct a directed graph where
all type parameters declared in the type parameter list are represented as vertices, and there is an edge from
type parameter T to type parameter S if T has S or S? as its bound. It is an error if the constructed directed
graph contains a cycle.

It is not syntactically possible for two type parameters in different type parameter lists to specify each other
as a bound.

It’s an error for a bound of a type parameter to be Nothing, or 
for several bound to have intersection Nothing (Nothing? is allowed). Two bounds of the same type parameter
cannot be different instantiations of the same generic type (TODO: in transitive set)

The same bound cannot be specified more than once for the same type parameter (BUG: implement)

TODO: Bounds, self-referential bounds, bound satisfaction, substitution. When exactly satisfaction is 
checked (nested generics, bounds satisfaction in bounds).

=== Variance
TODO: Co- and contravariance, safe occurrences of variant type parameter (including occurrences in 
type constraints, inner type constraints, and method constraints), safe invocations of private members. 
Variant conversions, infinite recursion issues, expanding cycles.

TODO: Workaround for `add` methods (extension methods).

=== Projections
TODO: Projections, valid occurrences of projections, members of projections. Meaning of projections of 
variant types. Interaction of declaration-site and use-side bounds, interaction with invisible types. 
Projections of a generic type in bounds in its own declaration.

=== Type Inference
TODO: Type variables, and fixed (external) type parameters (can originate from the same declaration). 
Type inference session (can include type variables from multiple declarations or multiple instances of 
the same declaration). Identity of type variables.

=== Restrictions on Usage
A generic class cannot have Throwable as a superclass. 




== Executable Code

=== General

=== Blocks
A block is a sequence of zero or more statements enclosed in curly braces { … }. Blocks can appear as 
bodies of methods, function expressions, loop bodies, or as initialization blocks. Standalone 
blocks cannot be used as statements to create nested scopes (but a similar effect could be used by run 
method from the standard library. TODO: Example).

A block is evaluated by sequential evaluation of the statements contained in it.

TODO

=== Statements
A statement can have one of the following forms: expression statement, declaration statement, 
assignment statement, loop statement or empty statement (the latter can be a result of putting multiple 
semicolons in a row).

TODO

=== Expression Statement
An expression statement is an expression followed by a semicolon (the latter can be implicit according 
to the grammar rules). An expression statement is evaluated by evaluation the expression. A value 
resulted from evaluation of the expression is discarded.

TODO

=== Single-Variable Declaration
A declaration statement can have one of the following forms: a variable declaration, a local function 
declaration, of a local type declaration. The declaration statement is terminated by a semicolon (the 
latter can be implicit according to the grammar rules). Local properties and extension properties are not 
supported. A variable declaration declares a read-only (val) or mutable (var) local variable. It can have an optional 
variable type specification after color, and an optional variable initializer after = token. At least one of 
them must be present. Evaluation of a variable declaration statement without an initializer does 
nothing. Evaluation of a variable declaration statement with an initializer consists of evaluation of the 
initializer and assignment of its result to the declared variable.

=== Multi-Variable Declaration
A declaration of the form val (v1, v2, …) = expr is equivalent to 
val $temp = expr 
val v1 = $temp.component1() 
val v2 = $temp.component2() 
…
where method names all begin with the prefix component followed a 1-based component index in 
decimal form without leading zeros, and $temp is a fresh name not visible in the user code. Instead of 
val keyword, var keyword may be used, then all declared variable become mutable.
Some or all components of a multi-declaration may have optional type annotations – if present, they are 
copied in the above expansion to declarations of corresponding variables (and can affect, for example, 
type inference in the corresponding $temp.componentN() invocations).
All component names v1, v2, … must be distinct.
Some collection types in stdlib (e.g. arrays) support a fixed number of componentN functions that 
extract their elements with index (N-1). componentN functions are also automatically generated for 
data classes, where N-th function extracts a value of the property initialized from N-th constructor 
parameter.

TODO: Components of type Nothing and control flow.

=== Local Function Declaration
Evaluation of a local function declaration has no effect at run-time. 

TODO

=== Local Type Declaration
A local type declaration can be a class declaration or an interface declaration. Evaluation of a local class 
of interface declaration does nothing.

TODO

=== Simple Assignment
[Note: An assignment is a statement. It produces no value and cannot be used as an expression. End 
Note]
TODO: Assignment targets: a variable, property, field, array element. Evaluation of assignment.
Multi-component assignment is not supported, only multi-component initialization.

=== Compound Assignment
TODO: Evaluation of assignment.

=== for Loop
TODO

==== Multi-Declarations in for Loop
TODO: for((key, value) in map)

=== while Loop
TODO

=== Literals
TODO: true, false, null, integers (dec, hex), floating-point, strings, chars.

=== Simple Names
A simple name consists of a single identifier. 
A simple name resolution can be in general described as follows. Each function body, anonymous function body,
accessor body, type body, or file represents a scope. Scopes can be nested. For each occurrence of a simple name
there a hierarchy of nested enclosing scopes, viewed from innermost to outermost (file scope).
Scopes are searched from innermost to outermost, performing a name lookup with a given name in each scope.
Once a match is found, the process stops and returns the match as a result. If the result turns out to be
not valid in the current context for some reason, the process does not resume. At each step, corresponding to
a type body, an additional step is inserted after it, looking for a matching symbol in the type's companion
object, if any.

=== Invocation Expressions
Invocation expressions has a form
       PrimaryExpression ( ArgumentList )
The PrimaryExpression must either be bound to a method group, or to a value that supports an 
invocation operation (e.g. a value of a functional type). Type arguments can only be provided if the 
primary expression is a method group containing a generic method.
To create an instance of a class, we call the constructor as if it were a regular function.
Named arguments. Named argument to a functional type invocation.

TODO

=== this Expression
TODO

=== super Access
Super-access is a value of the delegate object if it mentions an interface implemented via delegation. It 
cannot be used as a target of an assignment. In all other cases it can only be used at the left hand side of 
member access (dot operator).

There are no super expressions corresponding to this expressions introduced by extension functions or 
extension anonymous functions.

Super access cannot be used to access an extension.

TODO: Describe expressions of the form super<A>@B

=== class Expressions
T::class

Cannot be used on type parameters. No type arguments can be provided even if the type T is generic 
(except for the Array<T> type, for which a type argument must be provided, in/out projections in the 
argument are ignored). T cannot syntactically be a functional type. dynamic::class is not supported. The 
type of T::class expression is KClass<T>. (T)::class is not supported (BUG?).
java.lang.Object::class gives  kotlin.Any::class. kotlin.Nothing::class gives java.lang.Void::class.

=== Callable References
Callable references to local variables and parameters are not supported.

TODO: Member, non-member

=== Unary Expressions
TODO

=== Binary Expressions
TODO

=== Range Expression
TODO: Describe range expressions 1..10.

=== Conditional Expression
TODO: Describe if-else expression.

=== return Expression
The type of the return expression is kotlin.Nothing.

TODO: return, non-local return, labelled return.

=== throw Expression
The type of the throw expression is kotlin.Nothing.

TODO

=== is, !is Operators
The is operator checks if an expression is an instance of a type. If an immutable local variable or 
property is checked for a specific type, there’s no need to cast it explicitly, see §Smart-cast for exact 
details.

TODO

=== in, !in Operators
TODO: Usage with range expressions, with collections.

BUG: Order of evaluation of operands is reversed.

=== as, as? Expressions
TODO

=== Member Access Operator
TODO: with simple name RHS, and other expressions RHS

=== Safe Access Operator ?.
A package name cannot be followed with `?.`. A class name cannot be followed with `?.` and a nested 
class name.

=== when Expression
when matches its argument against all branches consequently until some branch condition is satisfied. 
when can be used either as an expression or as a statement. If it is used as an expression, the value of 
the satisfied branch becomes the value of the overall expression. If it is used as a statement, the values 
of individual branches are ignored. Just like with if, each branch can be a block, and its value is the 
value of the last expression in the block. The else branch is evaluated if none of the other branch 
conditions are satisfied. If when is used as an expression, the else branch is mandatory, unless the 
compiler can prove that all possible cases are covered with branch conditions. If many cases should be 
handled in the same way, the branch conditions may be combined with a comma.

TODO

=== Object Expressions
An object expression provides a way to declare an anonymous local class and instantiate it within an expression.
An object expression can specify the direct superclass and superinterfaces of the declared class, and
provide implementations of its members. The declared class does not have a name and is not denotable.
Evaluation of an object creation expression involves invocation of the superclass constructor,
evaluation of initialization blocks and property initializers within the expression, and
returns the created instance. The created instance is also available as this within the expression. If
an object expression has an immediately preceding label, then the created instance is also available
as labelled this expression that refers to this label.

The declared class cannot be abstract and must override all inherited abstract members. The declaration
of an anonymous class cannot have any modifiers.

A body of an anonymous object expression is mandatory (unlike other class and object declarations).

Otherwise, the body of an anonymous class is governed by the same rules as object declarations (see §?).`

=== Anonymous Functions

==== General
An anonymous function can have two different syntactic forms: a function expression, or a function 
literals. The difference is not purely syntactical – some constructs (e.g. return expressions) have 
different meaning within them.

TODO: Evaluation rules for anonymous functions. Body is not evaluated immediately. Rather, the whole 
expression produces a values of a functional type (§Functional Types), whose invocation results in 
evaluation of the body of the anonymous function. Captured variables, closure, exceptions.

==== Function Expression
A function expression looks very much like a regular function declaration, except that its name is 
omitted. (DEVIATION: The current compiler implementation allows to specify an optional name, but it 
has some unfortunate syntactic interactions with annotations and should be disallowed). It also cannot 
have a type parameter list (although can use type parameters that are already in scope). Its body can be 
either a block (§block) or = token followed by an expression (return expressions are not allowed in 
function expressions with expression body). Because a function expression lacks a name, a direct 
recursive invocation is not possible (a workaround is either to convert the expression into a named local 
function, or to assign the expression into a named mutable variable). A function expression cannot have 
@inline annotation. If return type is not specified and the function has a block body, then the return 
type is assumed to be kotlin.Unit. If return type is not specified and the function has an expression 
body, then the type can be inferred from the expression.

==== Function Literal
similar to a block, parameters are optional, parameter types are optional, the default parameter 
is `it`, cannot use return statement to exit function literal.

=== Static Type Assertion Expression
Deprecated. May cause parsing ambiguities between blocks and function literals.

=== Parenthesized Expression
Parenthesized expression has the same value and classification as the expression inside parentheses. Its 
main use is to change default parsing or grouping of expressions. It is possible to assign a parenthesized 
variable or property. Parentheses do not change order of evaluation of operands, although they could 
change order of evaluation of operators by means of changing the shape of a parse tree.

Parentheses has an effect on parsing blocks vs. function literals.

A prefix super<T> cannot be parenthesized unless it denotes a delegate.

Every expression can be placed in a context where an atomic expression is required by enclosing it in 
parentheses (provided it has suitable classification and type).
A method group cannot be parenthesized.

=== Invocation Expression
TODO

==== Passing Argument as a Trailing Function Literal
Empty argument list can be omitted in this case: run { … }

TODO

==== Implicit invoke Method Invocations
x.foo() cannot be rewritten multiple times, e.g. to x.foo.invoke.invoke()

TODO

=== Indexer Access Expression
Translated to an invocation of method get, or method set, or both. Index expressions are evaluated only 
once left-to-right.
Empty index list is not supported. Named indexes are not supported. Spread operator is supported 
(TODO: implement). Passing trailing lambda as the last parameter is not supported.

TODO: Do we support further rewriting of x.get(…) to x.get.invoke(…)?

=== Anonymous Object Creation Expressions
May specify no base class (object { … }), may specify a base class (with a constructor invocation) and 
zero or more interfaces (object : Base(…), I1, I2 { … }). Anonymous class cannot introduce its own type
parameters, but can use type parameters that are in scope. Every expression declares a distinct 
anonymous class -- even if two expressions are textually and semantically identical, their 
anonymous classes are unrelated. May not contain constructor declarations, but may contain 
initialization blocks. May not contain a companion object declaration. May contain nested class 
declarations, but they must be inner classes. May not contain nested interface declarations. Anonymous 
classes have access to current instances of their enclosing classes.

=== try Expressions
An exception type in a catch clause cannot be a type parameter (TODO: Implement). An exception type 
in a catch clause cannot be a nullable type. An exception type in a catch clause cannot be the type 
Nothing.

No initializer is allowed for a catch variable. A catch variable is considered initially assigned. A catch 
variable must have an explicit type that must be Throwable or subtype thereof. 

TODO: try-catch+, try-catch*-finally.



=== Order of Evaluation
Generally, the order of evaluation is left to right, non-lazy (eager). Some expressions have special rules for 
order of evaluation of their constituent parts (some of them may be not evaluated at all). Order of evaluation 
of named arguments corresponds to their order at the invocation site, not the declaration site.

TODO

== Name and Overload Resolution

=== General
TODO

=== Simple Names
TODO

=== Qualified Names
TODO

=== Name Lookup
TODO

=== Argument Lists
TODO

=== Positional Arguments
TODO

===	Named Arguments
TODO

=== Default Parameter Values
TODO

=== vararg Invocations
TODO

=== Matching Arguments with Parameters
TODO

=== Candidate Method Search
TODO

=== Potential Applicability
TODO

=== Actual Applicability
TODO

=== Overload Resolution

==== General
TODO

==== Better Conversion
TODO

==== Better Candidate
TODO

==== Best Candidate
TODO

=== Type Inference
TODO



== Threads and Concurrency

=== General
Not all platforms may provide multithreading.
TODO

=== Memory Model
TODO

=== Race Conditions
TODO

=== Synchronization
TODO: synchronized annotation

=== Thread Creation and Termination
TODO




== Java Interop

=== General
One of design goals of the Kotlin language is to provide a seamless interoperability with Java code, both when invoking Java code from Kotlin,
and when invoking Kotlin code from Java.
TODO

=== Mixed Projects
A Kotlin compiler is able to co-operate with a Java compiles to enable building of mixed projects,
where Java source files and Kotlin source files co-exist and are able to reference each other.

TODO

=== Platform Types
Because Java lacks built-in support for non-nullable types, some types exposed from Java to Kotlin need to be handled in a special way.

TODO

=== SAM Types
TODO: Conversions from lambda expressions to SAM types.

=== Optional Parameters
On the JVM, if all of the parameters of the primary constructor have default values, the compiler will 
generate an additional parameterless constructor which will use the default values. This makes it easier 
to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless 
constructors.

=== Using predefined types from java.lang package
TODO




== Reflection
TODO



== Standard Library Overview
TODO




== Documentation Comments
TODO


== Miscellaneous
ALL RULES FROM THIS SECTION SHOULD BE MOVED TO OTHER SECTIONS WHERE THEY BELONG


An interface method without a body can be marked abstract, but this is redundant.
Property initializers are not allowed in interfaces.
Override member must have the same or wider visibility as the overridden member.
Annotations on type parameters are not supported yet.
Spread operator – can pass an existing array, can join to create a new array.
Syntax for floating-point literals (including hex), round to zero, round to infinity, suffixes.
Generic properties.
Escape \$
Capitalizing first letter of a property in its accessors’ names.
Within default value for an optional parameter, the parameter is not definitely assigned (TODO: except 
within lambdas).
Visibility of generated componentN() methods in data classes is the same as visibility of the 
corresponding property.
Block cannot contains property declaration with setters, extension property declaration, or generic 
property declaration.
It is an error if right operand of / or % operator for any integral type is constant expression with zero 
value. Operators / and % for any integral type throw ArithmeticException if right operand is zero at 
runtime. Arithmetic operators overflow silently. Operator > implements strict linear order on integral 
types. m<n is equivalent to n>m, m<=n is equivalent to m<n || m==n, m>=n is equivalent to m>n || 
m==n for integral types and type Char. The type Char supports binary operators +, - with the right 
operand of type Int, relational operators >,<,>=,<=.
Every type (inlcuding nullabe types) supports operators ==, !=, ===, !==, they are not mentioned 
specifically for each type.
NaN != NaN, if both operands of the same non-nullable floating-point type (so reflexivity and trichotomy 
properties for equality and comparison operators are violated). This does not apply for method equals 
invocations.
@native annotation is only allowed for top-level functions.
An enum constructor cannot explicitly delegate to super .
return expression are not allowed in functions with expression body. return expression without label 
return from nearest enclosing named function or anonymous function (TODO: it is more complicated).
Anonymous function can use expression body.
Type parameter list is not allowed for anonymous functions.
A package name cannot be followed with `?.`. A class name cannot be followed with `?.` and a nested 
class name.
{ … } is parsed as block or as function literal depending on context (e.g. function body, class body, after 
`for`, `if`, `else`, `do`, `while`, `try`, `catch`, `finally`, after `->` in a when branch). To specify a function 
literal in a context where { … } would be pased as a block, it can be parenthesized ({ … }) or explicit 
parameter list can be provided { -> … } (even if it’s empty). (TODO: block/f. literal can be preceded by 
annotations and at most one label; providing several labels can force it to be parsed as f.literal)
TODO: empty or semicolon branches in if/else
An object declaration introduces both a type name and an object name.
`else` branch must be the last branch in `when` expression.
Exhaustive when check.
Soft keywords:
abstract annotation by catch companion constructor dynamic enum file final 
finally get import init inner internal open out override private protected 
public reified sealed set vararg where
  http://youtrack.jetbrains.com/issue/KT-2877
Relax this rule, but take care about identifier not supported by the platform.
Space?

Left names in dotted names can be merged symbols (even of different kinds, e.g. class and package), whose eventual
meaning is determined by which names to the right are looked up in them.

Overloading is possible based on constraints only, provided that erased signatures are different.

To access a member of an enclosing class using a simple name it is necessary to have an access to this instance of
an enclosing class. In some contexts (e.g. withing object declarations) this instances of an enclosing classes
are not available, and hence an access to a member of an enclosing class is not possible using a simple name
(unless there is an implicit receiver of the corresponding type introduces by other means, e.g. through an extension
function, or by deriving the object from an enclosing class).

@synchronized and default parameter values
@synchronized and inline
annotations on annotation parameters
priority list for annotation targets: param, field, property, setter, getter
investigate: non-nullable types T!
investigate: import com.acme.A.foo where A is an object

import directives can import functional members only if they are top-level.
Secondary constructors cannot have val/var keywords in parameter declarations.
Recursive generic constraints.
annotations on init blocks.
Nested classes are not inherited, and need to be qualified with their declaring type when references from typed derived
form the declaring type (TODO: consider enabling inheritance for inner classes, or an equivalent to bring their
constructors in scope in derived classes).

initializer block can have annotations with EXPRESSION target.

TODO: Do we support inheritance from inner classes outside of their declaring classes, and do we have any syntax similar
to Java qualified superclass constructor invocation (JLS 8, §8.8.7.1 Explicit Constructor Invocations)?

At most 1 parameter of a function can be vararg, but not necessarily the last one.

interface A : C { // Error
    public interface B {}
}

interface C : A.B { }

It is not allowed to manually inherit from Enum<E> type (TODO: implement).

Do we need constructor for primary constructors?


what is a non-empty package (in binary form and in source form)?
no backtracking
not including the last identifier
try to find visible type with next identifier
we depend on order of dependencies, and select the 1st type
all except last identifer resolve to a type
all import * directives create all unified scope enclosing the file scope
import * may import ambiguous members
import * may import nothing
inner classes from generic classes?
package memebrs do not include subpackages
package members inlude type, props, funs (including extensions)
TODO: import from singletons?

import A -- TODO: error?
Do we resolve simple names to top-level symbols in root package?
Repeat steps from the last case.
2 imports ends on the same identifier - error
if class found in 2 modules - select one, and import its constructors
all props and funs imported all with the same priority

ambiguous classes in type position?
fqn vs. canonical in java
stop package at generic arguments

TODO: members from default package

How do we place annotations for the element type int in the array type int[]?

If overriding member does not specify visibility and all overridden members have the same visibility
(or there is only one overridden member), then the overriding method inherits that visibility. If not
all overridden members have the same visibility, then the overriding method must specify it visibility
explicitly, otherwise a compile-time error occurs. (TODO: verify this)



==== Import Directive Priorities
Import directives priorities (from highest to lowest):
1. Explicit user imports
2. Current package symbols
3. Top-level packages
4. Explicit default imports
5. User imports with "*"
6. Default imports with "*"

==== Anonynmous Types in Public API
Methods and properties can return anonymous type originating from object literals, or generic types constructed
with anonymous types. These type are not denotable. In Java interop scenarion anonymous types are replaced with
their first declared supertype, or Any if no supertype is specified. It potentially can result in type safefy
violations and heap pollution if, for example, Java overrides a method returning an anonymous type, and because
the override return type is Any, it can return an object of unrelated type, that will be visible in Kotlin
as an object of the anonymous types. Because JVM enforces type safety on a lower level, such scenarions will
usually eventually result in CastClassException or ArrayStoreException, but it can occur in a distant position
in code and may be difficult to debug.

A class can inherit multiple methods with the same signature, but unrelated return types, provided that it is abstract
or overrides them with a method that is a subtype of all those return types (there is always at least one such type,
namely Nothing).

When compiling to JVM, the name DefaultImpls in reserved in interfaces that provide default implementations for
functional members. This name is used for nested class that is exposed to Java and contains the default implementations.

TODO: Spec DefaultImpls nested class, including representation of methods in generic interfaces (dependencies between
type parameters).

TODO: Spec lateinit properties (only var). There is no direct way to check if a lateinit property is already initialized
(a workaround it to try to read from it and catch an exception), and there is no way to uninitialize it (set it to null
to release a reference to an object). kotlin.UninitializedPropertyAccessException 
TODO: Spec null safety and possible violations

TODO: Spec heap pollution

TODO: Do we copy annotation from default implementations in interfaces to corresponding classes?

TODO: Synchronized in interfaces?

TODO: Spec const vals

TODO: Generic anonymous objects / local classes, out-projections?

fun main(args: Array<String>) {
    fun f<T>(x : T) = object { val X = x };
    val s = listOf(f(1), f(""))
    val y = s[0].X
}

TODO: pre- and postfix increment/decrement operators

TODO: (x is Int?) Nullable mark is redundant here and results in a warning.

TODO: @KotlinOperator and @KotlinInfix annotations for Java interop

Properties declared in parameter declarations cannot be abstract or external.

Modifier `abstract` is not applicable to property accessors.

==== Constituent Types
For every type T, there is a corresponding set S of its _constituent types_, defined as the transitive closure of
the singleton set {T} under the following rules:
* If a nullable type U? is in S, then U is in S.
* If a constructed generic type G<A1, …, An> is in S, then for each its type argument Ai that is a type (i.e. not a projection argument),
Ai is in S.
* If a constructed generic type G<A1, …, An> is in S, then for each its type argument Ai that is a projection argument of the form
`out Ti` or `in Ti`, Ti is in S.
TODO: inner types
[Note: Note that every type is always a constituent type of itself. End Note]

[Example: 
The constituent types of the type A<T?, B<out B<X, X>, C<*>>> are { A<T, B<out B<X, X>, C<*>>>, T?, T, B<out B<X, X>, C<*>>, B<X, X>, C<*>, X }.
End Example]

==== Finite Bound Restriction
For purposes of this section, a non-inner nested generic type is considered a standalone generic type independent of its containing types,
and an inner type having its own type parameters or nested within types having type parameters is considered a standalone generic type whose
type parameter list includes both its own type parameters and copies all type parameters of all its containing types with properly reproduced bounds.
Type parameters copied from containing types are considered distinct from the original type parameters of the containing types.

TODO: Define "properly reproduced". In short, it means that any references to original type parameters in bounds are replaced with
references to copied type parameters, so for example, if a type parameter T : C<T> is copied to type parameter T1 then it takes
form T1 : C<T1>, rather than T1 : C<T>.

Construct a directed graph G whose vertices are all type parameters of the declarations of all generic types in the program. For every
projection type argument A in every generic type B<…> in the set of constituent types of every bound of every type parameter T in G, add an
edge from T to U, where U is the type parameter of the declaration of B<…> corresponding to the type argument A. It is a compile-time error
if the graph G has a cycle. [Note: Type parameters of generic methods and properties do not partitipate in this rule. End Note] 

TODO: inner classes 

[Example:
The following declaration is invalid, because there is an edge T → T, forming a cycle:

interface A<T : A<*>>

The bound A<*> is a projection with an implicit bound. If that bound is made explicit, the type A<*> takes an equivalent form A<out A<*>>.
In the same way, it can be further rewritten in an equivalent from A<out A<out A<*>>>, and so on. In its fully expanded form this bound would
be infinite. The purpose of this rule is to avoid such infinte types, and type checking difficulties associated with them.

The following two mutually dependent declarations are invalid, because there are edges T → S and S → T, forming a cycle:

class B<T : C<*>>
class C<S : B<*>>

On the other hand, the following declaration is perfectly valid:

class D<K, V : D<*, V>>

End Example]

Construct a directed graph that contains all type parameters of all declarations of generic classes and interfaces in the program as its vertices.
Different type parameters are considered distinct despite that they may have identical names. Some vertices may be connected by edges. There
are two possible kinds of edges: non-expanding and expanding. For each type parameter T, consider all constructed generic types among all
constituent types of all immediate supertypes of its owner (the generic class or interface declaration that declares T in its type parameter list).
If any of those constructed generic types have T or T? as a type argument corresponding to a type parameter S, then add a non-expanding edge
from T to S. If any of those constituent generic types have T as a constituent type of a type argument corresponding to a type parameter S,
but that type argument is not simply of the form T or T?, then add an expanding edge from T to S. It's a compile-time error if the graph
contains a cycle that has at least one expanding edge.
[Examples: TODO]


TODO: Ban mutually recusive infinitely expanding bounds:

interface A<T : B<*>>
interface B<S : A<*>>

Subtyping relationships is to be decided inductively, i.e. have a finite proof.

interface N<in T>
interface A<S> : N<N<A<A<S>>>>


TODO: @setparam:

The declared visibility of an override must be not less than the declared visibility of the overridden member (TODO: declared includes default).

Local functions cannot have visibility modifiers. Local classes can have visibiliy modifiers `private`, `public`, `internal` (TODO: discuss).



9.4.1.3 Inheriting Methods with Override-Equivalent Signatures
`operator` is inherited (at least one inheritance path is enough)

TODO: parameter names in functional types, no vararg, no duplicate parameter names in functional types, do we resolve to them in annotations?

local functions can be operators
TODO: no non-public set in interfaces
TODO: named arguments are not allowed for function types (both in () and .invoke() invocations)

TODO: top-level non-extension invoke cannot be operator (packageName() is not allowed)
TODO: x[i] is not translated to x.get.invoke(), because property get cannot be operator; function paramemeter or local cannot be operator
TODO: super.foo cannot refer to abstract member
TODO: arguments can be renamed in overrides, invocation uses name from static type of the target
TODO: an overriding function cannot provide default values for its parameters, they are always inherited. No more than 1 overridden
declaration is allowed to provide a default value (even if values are identical)
TODO: order of evaluation for constants: topo sorting, no cycles
TODO: val property can be overridden by var property, but not vice versa
TODO: no private abstract accessors in properties

==== Expansive Inheritance in presence of type projections
Fisrt consider a simplified case, when only *-projections may exist (no in- or out-projections).
In the following we assume that any occurrence of a nullable type T? is immediately replaced with
corresponding unwrapped type T.

For every *-projection type argument in an instantiation G' of G<...>, consider all bounds (including inherited)
of the corresponding type parameter T. Those bounds can contain (or just be) type parameters of the declaration of G<...>,
including the current type parameter T. Process every bound B in order. If the bound B does not contain any type parameters of
G<...>, then ignore this bound. Otherwise, the bound B contains one or more occurrences of one of more type
parameters of G<...> (possibly, including the T itself). We need to construct a substituted bound B' from B by
replacing those occurrences by some types derived from G' according to the following rules.
Process every occurrence in order. If the occurrence represents a type parameter of G<...> such that the
corresponding type argument in G' is a regular (non-projection) argument, then substitute that argument for this occurrence.
Otherwise (when the corresponding type argument is a projection), then substitute Nothing for this occurrence.


BUG:
class A<T : B<*>>
class B<S : A<S>>